EXCEPTION:
------------
EXCEPTION IS AN ERROR OCCURRED DURING RUNTIME.
WHENEVER RUNTIME ERROR OCCURE USE AN APPROPRIATE EXCEPTION NAME IN EXCEPTION SECTION. EXCEPTION HANDLER UNDER

THERE ARE 2 TYPES OF EXCEPTIONS SUPPORTED BY ORACLE

1.  	PREDEFINED EXCEPTIONS
2.  	USER-DEFINED EXCEPTIONS


1. PREDEFINED EXCEPTIONS
ORACLE DEFINED 20 PREDEFINED EXCEPTIONS NAMES FOR REGULARLY OCCURED ERRORS. 
WHENEVER THESE ERRORS OCCURE USE APPROPRIATE EXCEPTIONNAME IN EXCEPTION HANDLER.

SYNTAX:

WHEN PREDEFINED_EXCEPTIONNAME1 THEN
STATEMENTS;
WHEN PREDEFINED_EXCEPTIONNAME 2 THEN  
STATEMENTS;
------------------
------------------
WHEN OTHERS THEN
STATEMENTS;


PREDEFINED EXCEPTIONS
---------------------

I) NO_DATA_FOUND
II) TOO_MANY-ROWS
III) ZERO DIVIDE
IV) INVALID.CURSOR
V)CURSOR_ALREADY-OPEN
VI) INVALID_NUMBER
VII)VALUE-ERROR


I) NO-DATA-FOUND
----------------

WHEN A PL/SQL BLOCK CONTAINS SELECT---.--- INTO CLAUSE & ALSO IF REQUESTED DATA NOT AVALIABLE IN A TABLE 
ORACLE SERVER RETURNS AN ERROR ORA-1403: NO DATA FOUND. TO HANDLE THIS ERROR WE ARE USING NO_DATA_ FOUND EXCEPTIONNAME.

EX.

DECLARE
 V_ENAME  VARCHAR2 (10);
 V_SAL NUMBER(10);
BEGIN
 SELECT ENAME, SAL INTO V_ENAME, V_SAL
 FROM EMP 
 WHERE EMPNO = &NO;
  DBMS_OUTPUT.PUT_LINE (V_ENAME ||''|| V_SAL);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
   DBMS_OUTPUT.PUT_LINE ('EMPLOYEE DOES NOT EXIST');
END;
/

(OUTPUT) =>ENTER VALUE FOR NO: 7902
FORD 4000
=>/

ENTER VALUE FOR NO: 9999
EMPLOYEE DOES NOT EXIST

II) TOO_MANY_ROWS
------------------

WHEN A SELECT -INTO CLAUSE TRY TO RETURN MORE THAN ONE RECORD OR MORE THAN ONE VALUE THEN ORACLE SERVER RETURNS AN ERROR ORA-1422 :EXACT FETCH RETURNS MORE THAN REQUESTED NUMBER OF ROWS. TO HANDLE THIS ERROR WE ARE USING TOO_MANY_ROWS EXCEPTIONNAME.

EX:

DECLARE
V_SAL NUMBER (10);
BEGIN
SELECT SAL INTO V_SAL FROM EMP;
DBMS_OUTPUT.PUT_LINE (V_SAL);
EXCEPTION
WHEN TOO_MANY_ROWS THEN
DBMS_OUTPUT.PUT_LINE('NOT TO RETURN MORE ROWS');
END;
/


III) ZERO_DIVIDE
--------------------

ORA-1476: DIVISOR IS EQUAL TO ZERO

EX:

DECLARE
  DIVIDENT  NUMBER(10);
  DIVISOR NUMBER (10);
  C NUMBER (10);
BEGIN
  DIVIDENT :=5;
  DIVISOR:=0;
  C:= DIVIDENT/DIVISOR ;
   DBMS_OUTPUT.PUT_LINE (C);
EXCEPTION
  WHEN ZERO_DIVIDE THEN 
    DBMS_OUTPUT.PUT_LINE ('DIVISOR CANNOT BE ZERO');
END;
/



IV) INVALID CURSOR

WHENEVER WE ARE PERFORMING INVALID OPERATIONS ON THE CURSOR ORACLE SERVER RETURNS AN ERROR I.E. 
IF YOU ARE TRY TO CLOSE THE CURSOR WITHOUT OPENING THE CURSOR ORACLE SERVER RETURNS AN ERROR 
ORA-1001: INVALID CURSOR. TO HANDLE THIS CURSOR WE ARE USING INVALID_CURSOR EXCEPTIONNAME.

EX:

DECLARE
 CURSOR C1 IS SELECT * FROM EMP;
 I EMP%ROWTYPE;
BEGIN
  LOOP
   FETCH C1 INTO I;
   EXIT WHEN C1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(I.ENAME||' '|| I.SAL);
  END LOOP;
 CLOSE C1;
EXCEPTION
 WHEN INVALID_CURSOR THEN
   DBMS_OUTPUT.PUT_LINE ('FIRST WE MUST OPEN THE CURSOR');
END;
/

V) CURSOR_ALREADY_OPEN:

WHEN WE ARE TRY TO REOPEN THE CURSOR WITHOUT CLOSING THE CURSOR ORACLE SERVER RETURNS AN ERROR
ORA-6511: CURSOR ALREADY OPEN TO HANDLE THIS ERROR WE ARE USING CURSOR_ALREADY_OPEN EXCEPTIONNAME.

EX:

DECLARE
  CURSOR C1 IS SELECT * FROM EMP;
  I EMP%ROWTYPE;
BEGIN
  OPEN C1;
   LOOP
    FETCH C1 INTO I;
    EXIT WHEN C1%NOTFOUND;
     DBMS_OUTPUT.PUT_LINE (I.ENAME||' '||I.SAL);
  END LOOP;
 OPEN C1;
EXCEPTION
 WHEN CURSOR_ALREADY_OPEN THEN
   DBMS_OUTPUT.PUT_LINE ('BEFORE REOPEN WE MUST CLOSE THE CURSOR');
END;
/

INVALID_NUMBER, VALUE_ERROR

WHENEVER WE ARE TRY TO CONVERT STRING TYPE TO NUMBER TYPE ORACLE SERVER RETURN ERRORS INVALID_NUMBER VALUE ERROR.

VI) INVALID_NUMBER

WHEN A PL/SQL BLOCK CONTAINS SQL STATEMENTS & ALSO IF YOU ARE TRY TO CONVERT STRING TYPE TO NUMBER TYPE ORACLE SERVER RETURNS AN ERROR, ORA-1722: INVALID NUMBER. TO HANDLE THIS ERROR WE ARE USING INVALID_ERROR EXCEPTIONNAME.

EX:

BEGIN
  INSERT INTO EMP (EMPNO, SAL) VALUES (1, 'ABC');
EXCEPTION
  WHEN INVALID_NUMBER THEN
    DBMS_OUTPUT.PUT_LINE ('INSERT PROPER DATA ONLY');
END;
/





VII) VALUE_ERROR
WHEN A PL/SQL BLOCK CONTAINS PL/SQL STATEMENTS & ALSO IF YOU ARE TRY TO CONVERT STRING TYPE TO NUMBER TYPE ORACLE SERVER RETURNS AN ERROR,
ORA-6502: NUMBERIC OR VALUE ERROR: CHARACTER TO NUMBER CONVERSION ERROR. TO HANDLE THIS ERROR WE ARE USING VALUE_ERROR EXCEPTIONNAME.

EX: 1

DECLARE
 Z NUMBER (10);
BEGIN
 Z := 'X' + 'Y';
  DBMS_OUTPUT.PUT_LINE (Z);
EXCEPTION
 WHEN VALUE_ERROR THEN
  DBMS_OUTPUT.PUT_LINE ('ENTER PROPER DATA ONLY');
END;
/


EX:2
--------

DECLARE
 Z NUMBER(5);
BEGIN
 Z := '123456';
  DBMS_OUTPUT.PUT_LINE(Z);
EXCEPTION
 WHEN VALUE_ERROR THEN
  DBMS_OUTPUT.PUT_LINE('VALUE ERROR OCCURRED: CANNOT ASSIGN THIS VALUE.');
END;
/
